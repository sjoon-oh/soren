--- memcached-orig.c	2023-05-30 11:02:57.791892836 +0900
+++ memcached.c	2023-05-30 11:10:28.722898361 +0900
@@ -61,6 +61,10 @@
 #include "tls.h"
 #endif
 
+// Memcached-Soren
+// Author: sjoon@kaist.ac.kr
+#include "../../../src/soren-c.h"
+
 #if defined(__FreeBSD__)
 #include <sys/sysctl.h>
 #endif
@@ -5759,6 +5763,9 @@
     size_t ntokens;
     int comm;
 
+    int timestamp_idx;
+    size_t memsz;
+
     assert(c != NULL);
 
     MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
@@ -5779,6 +5786,7 @@
         return;
     }
 
+    memsz = strlen(command) + 1;
     ntokens = tokenize_command(command, tokens, MAX_TOKENS);
     if (ntokens >= 3 &&
         ((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
@@ -5792,15 +5800,48 @@
                 (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
                 (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
                 (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
+        
+        // Memcached-Soren
+        // Author: sjoon@kaist.ac.kr
+        timestamp_idx = cwMarkTsBefore();
+        cwPropose(
+            (uint8_t*)command,
+            memsz,
+            (uint8_t*)tokens[KEY_TOKEN].value,
+            tokens[KEY_TOKEN].length, 0
+        );
+        cwMarkTsAfter(timestamp_idx);
 
         process_update_command(c, tokens, ntokens, comm, false);
 
     } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
 
+        // Memcached-Soren
+        // Author: sjoon@kaist.ac.kr
+        timestamp_idx = cwMarkTsBefore();
+        cwPropose(
+            (uint8_t*)command,
+            strlen(command) + 1,
+            (uint8_t*)tokens[KEY_TOKEN].value,
+            tokens[KEY_TOKEN].length, 0
+        );
+        cwMarkTsAfter(timestamp_idx);
+
         process_update_command(c, tokens, ntokens, comm, true);
 
     } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
 
+        // Memcached-Soren
+        // Author: sjoon@kaist.ac.kr
+        timestamp_idx = cwMarkTsBefore();
+        cwPropose(
+            (uint8_t*)command,
+            strlen(command) + 1,
+            (uint8_t*)tokens[KEY_TOKEN].value,
+            tokens[KEY_TOKEN].length, 0
+        );
+        cwMarkTsAfter(timestamp_idx);
+
         process_arithmetic_command(c, tokens, ntokens, 1);
 
     } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
@@ -7796,6 +7837,11 @@
 
 static void sig_handler(const int sig) {
     printf("Signal handled: %s.\n", strsignal(sig));
+
+    // Memcached-Soren
+    // Author: sjoon@kaist.ac.kr
+    cwCleanSoren();
+
     exit(EXIT_SUCCESS);
 }
 
@@ -7805,6 +7851,11 @@
 
 static void sig_usrhandler(const int sig) {
     printf("Graceful shutdown signal handled: %s.\n", strsignal(sig));
+
+    // Memcached-Soren
+    // Author: sjoon@kaist.ac.kr
+    cwCleanSoren();
+    
     stop_main_loop = true;
 }
 
@@ -8441,6 +8492,13 @@
     ext_cf.wbuf_count = ext_cf.page_buckets;
 #endif
 
+    // Memcached-Soren
+    // Author: sjoon@kaist.ac.kr
+    const int MAX_TIMESTAMP_RECORDS = 10000000;
+
+    cwInitSoren(10, 2);
+    cwInitTs(MAX_TIMESTAMP_RECORDS);
+
     /* Run regardless of initializing it later */
     init_lru_maintainer();
 
