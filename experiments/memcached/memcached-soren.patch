--- memcached-orig.c	2023-06-12 20:41:44.515079792 +0900
+++ memcached.c	2023-06-12 20:43:07.495080808 +0900
@@ -61,6 +61,12 @@
 #include "tls.h"
 #endif
 
+// Memcached-Soren
+// Author: sjoon@kaist.ac.kr
+#include "../../../src/soren-c.h"
+
+int sorenReplayFuncWrapper(uint8_t* arg_memaddr, size_t arg_memsz, int argc, void* argv);
+
 #if defined(__FreeBSD__)
 #include <sys/sysctl.h>
 #endif
@@ -5759,6 +5765,9 @@
     size_t ntokens;
     int comm;
 
+    int timestamp_idx;
+    size_t memsz;
+
     assert(c != NULL);
 
     MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
@@ -5779,6 +5788,7 @@
         return;
     }
 
+    memsz = strlen(command) + 1;
     ntokens = tokenize_command(command, tokens, MAX_TOKENS);
     if (ntokens >= 3 &&
         ((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
@@ -5792,15 +5802,48 @@
                 (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
                 (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
                 (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
+        
+        // Memcached-Soren
+        // Author: sjoon@kaist.ac.kr
+        timestamp_idx = cwMarkTsBefore();
+        cwPropose(
+            (uint8_t*)command,
+            memsz,
+            (uint8_t*)tokens[KEY_TOKEN].value,
+            tokens[KEY_TOKEN].length, 0
+        );
+        cwMarkTsAfter(timestamp_idx);
 
         process_update_command(c, tokens, ntokens, comm, false);
 
     } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
 
+        // Memcached-Soren
+        // Author: sjoon@kaist.ac.kr
+        timestamp_idx = cwMarkTsBefore();
+        cwPropose(
+            (uint8_t*)command,
+            strlen(command) + 1,
+            (uint8_t*)tokens[KEY_TOKEN].value,
+            tokens[KEY_TOKEN].length, 0
+        );
+        cwMarkTsAfter(timestamp_idx);
+
         process_update_command(c, tokens, ntokens, comm, true);
 
     } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
 
+        // Memcached-Soren
+        // Author: sjoon@kaist.ac.kr
+        timestamp_idx = cwMarkTsBefore();
+        cwPropose(
+            (uint8_t*)command,
+            strlen(command) + 1,
+            (uint8_t*)tokens[KEY_TOKEN].value,
+            tokens[KEY_TOKEN].length, 0
+        );
+        cwMarkTsAfter(timestamp_idx);
+
         process_arithmetic_command(c, tokens, ntokens, 1);
 
     } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
@@ -7796,6 +7839,12 @@
 
 static void sig_handler(const int sig) {
     printf("Signal handled: %s.\n", strsignal(sig));
+
+    // Memcached-Soren
+    // Author: sjoon@kaist.ac.kr
+    cwDumpTs();
+    cwCleanSoren();
+
     exit(EXIT_SUCCESS);
 }
 
@@ -7805,6 +7854,11 @@
 
 static void sig_usrhandler(const int sig) {
     printf("Graceful shutdown signal handled: %s.\n", strsignal(sig));
+
+    // Memcached-Soren
+    // Author: sjoon@kaist.ac.kr
+    cwCleanSoren();
+    
     stop_main_loop = true;
 }
 
@@ -8441,6 +8495,13 @@
     ext_cf.wbuf_count = ext_cf.page_buckets;
 #endif
 
+    // Memcached-Soren
+    // Author: sjoon@kaist.ac.kr
+    const int MAX_TIMESTAMP_RECORDS = 10000000;
+
+    cwInitSoren(sorenReplayFuncWrapper);
+    cwInitTs(MAX_TIMESTAMP_RECORDS);
+
     /* Run regardless of initializing it later */
     init_lru_maintainer();
 
@@ -9793,3 +9854,103 @@
 
     return retval;
 }
+
+// Memcached-Soren
+// Author: sjoon@kaist.ac.kr
+int sorenReplayFuncWrapper(uint8_t* arg_memaddr, size_t arg_memsz, int argc, void* argv) {
+
+    // printf("Replayer wrapper called.\n");
+
+    conn c;
+    memset(&c, 0, sizeof(struct conn)); // Make it all zeros.
+
+    c.read = NULL;
+    c.sendmsg = NULL;
+    c.write = NULL;
+    c.rbuf = c.wbuf = 0;
+    c.ilist = 0;
+    c.suffixlist = 0;
+    c.iov = 0;
+    c.msglist = 0;
+    c.hdrbuf = 0;
+
+    c.rsize = DATA_BUFFER_SIZE;
+    c.wsize = DATA_BUFFER_SIZE;
+    c.isize = ITEM_LIST_INITIAL;
+    c.suffixsize = SUFFIX_LIST_INITIAL;
+    c.iovsize = IOV_LIST_INITIAL;
+    c.msgsize = MSG_LIST_INITIAL;
+
+    c.rbuf = (char *)malloc((size_t)c.rsize);
+    c.wbuf = (char *)malloc((size_t)c.wsize);
+    c.ilist = (item **)malloc(sizeof(item *) * c.isize);
+    c.suffixlist = (char **)malloc(sizeof(char *) * c.suffixsize);
+    c.iov = (struct iovec *)malloc(sizeof(struct iovec) * c.iovsize);
+    c.msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c.msgsize);
+
+    c.icurr = c.ilist;
+    c.suffixcurr = c.suffixlist;
+
+
+    token_t tokens[MAX_TOKENS];
+    size_t ntokens = 0;
+    int comm;
+
+    char* command = (char*)arg_memaddr;
+    char *start, *end;
+
+    // Already tokenized, thus record it by '\0'.
+    start = end = command;
+    for (int i = 0; i < arg_memsz; i++) {
+        if (*end == '\0') {
+            if (start != end) {
+                tokens[ntokens].value = start;
+                tokens[ntokens].length = end - start;
+                ntokens++;
+                if (ntokens == MAX_TOKENS - 1) {
+                    end++;
+                    start = end;
+                    break;
+                }
+            }
+            start = end + 1;
+        }
+        end++;
+    }
+
+    if (start != end) {
+        tokens[ntokens].value = start;
+        tokens[ntokens].length = end - start;
+        ntokens++;
+    }
+
+    tokens[ntokens].value =  *end == '\0' ? NULL : end;
+    tokens[ntokens].length = 0;
+    ntokens++;
+
+    if ((ntokens == 6 || ntokens == 7) &&
+        ((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
+        (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
+        (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
+        (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
+        (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
+
+        // Debug:
+        // printf("Wrapper: process_update_command call, token: %ld\n", ntokens);
+        // printf("Wrapper: Content - %s %s %s %s %s\n", tokens[0].value, tokens[1].value, tokens[2].value, tokens[3].value, tokens[4].value);
+
+        process_update_command(&c, tokens, ntokens, comm, false);
+
+        // Debug:
+        // printf("Wrapper: end, %s\n", tokens[1].value);
+    }
+
+    free(c.rbuf);
+    free(c.wbuf);
+    free(c.ilist);
+    free(c.suffixlist);
+    free(c.iov);
+    free(c.msglist);
+
+    return 0;
+}
\ No newline at end of file
