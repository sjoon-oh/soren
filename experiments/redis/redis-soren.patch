--- src/server-orig.c	2023-06-26 17:29:28.054028109 +0900
+++ src/server.c	2023-06-26 17:32:52.219035410 +0900
@@ -34,14 +34,19 @@
 #include "bio.h"
 #include "latency.h"
 #include "atomicvar.h"
 #include "mt19937-64.h"
 #include "functions.h"
 #include "syscheck.h"
 
+
+// Redis-Soren
+// Author: sjoon@kaist.ac.kr
+#include "sds.h"
+
 #include <time.h>
 #include <signal.h>
 #include <sys/wait.h>
 #include <errno.h>
 #include <assert.h>
 #include <ctype.h>
 #include <stdarg.h>
@@ -62,14 +67,23 @@
 #include <sys/socket.h>
 #include <sys/resource.h>
 
 #ifdef __linux__
 #include <sys/mman.h>
 #endif
 
+// Redis-Soren
+// Author: sjoon@kaist.ac.kr
+#include "../../../../src/soren-c.h"
+
+#include <pthread.h>
+pthread_mutex_t g_call_lock = PTHREAD_MUTEX_INITIALIZER;
+
+int sorenReplayFuncWrapper(uint8_t* arg_memaddr, size_t arg_memsz, int argc, void* argv);
+
 #if defined(HAVE_SYSCTL_KIPC_SOMAXCONN) || defined(HAVE_SYSCTL_KERN_SOMAXCONN)
 #include <sys/sysctl.h>
 #endif
 
 /* Our shared "common" objects */
 
 struct sharedObjectsStruct shared;
@@ -1158,14 +1172,17 @@
  *
  * Everything directly called here will be called server.hz times per second,
  * so in order to throttle execution of things we want to do less frequently
  * a macro is used: run_with_period(milliseconds) { .... }
  */
 
 int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
+
+    pthread_mutex_lock(&g_call_lock);
+
     int j;
     UNUSED(eventLoop);
     UNUSED(id);
     UNUSED(clientData);
 
     /* Software watchdog: deliver the SIGALRM that will reach the signal
      * handler if we don't return here fast enough. */
@@ -1416,14 +1433,16 @@
 
     /* Fire the cron loop modules event. */
     RedisModuleCronLoopV1 ei = {REDISMODULE_CRON_LOOP_VERSION,server.hz};
     moduleFireServerEvent(REDISMODULE_EVENT_CRON_LOOP,
                           0,
                           &ei);
 
+    pthread_mutex_unlock(&g_call_lock);
+
     server.cronloops++;
     return 1000/server.hz;
 }
 
 
 void blockingOperationStarts() {
     if(!server.blocking_op_nesting++){
@@ -3278,14 +3297,16 @@
  *
  */
 void call(client *c, int flags) {
     long long dirty;
     uint64_t client_old_flags = c->flags;
     struct redisCommand *real_cmd = c->realcmd;
 
+    pthread_mutex_lock(&g_call_lock);
+
     /* Initialization: clear the flags that must be set by the command on
      * demand, and initialize the array for additional commands propagation. */
     c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);
 
     /* Redis core is in charge of propagation when the first entry point
      * of call() is processCommand().
      * The only other option to get to call() without having processCommand
@@ -3476,14 +3497,16 @@
     /* Client pause takes effect after a transaction has finished. This needs
      * to be located after everything is propagated. */
     if (!server.in_exec && server.client_pause_in_transaction) {
         server.client_pause_in_transaction = 0;
     }
 
     server.core_propagates = prev_core_propagates;
+    
+    pthread_mutex_unlock(&g_call_lock);
 }
 
 /* Used when a command that is ready for execution needs to be rejected, due to
  * various pre-execution checks. it returns the appropriate error to the client.
  * If there's a transaction is flags it as dirty, and if the command is EXEC,
  * it aborts the transaction.
  * Note: 'reply' is expected to end with \r\n */
@@ -3934,14 +3957,45 @@
         (server.client_pause_type == CLIENT_PAUSE_WRITE && is_may_replicate_command)))
     {
         c->bpop.timeout = 0;
         blockClient(c,BLOCKED_POSTPONE);
         return C_OK;       
     }
 
+    // Redis-Soren
+    // Author: sjoon@kaist.ac.kr
+    int timestamp_idx;
+    uint32_t hashval;
+
+    if (is_write_command) {
+
+        timestamp_idx = cwMarkTsBefore();
+        if (strcmp(c->argv[0]->ptr, "HMSET") == 0)
+            hashval = cwSorenHash(c->argv[1]->ptr, strlen(c->argv[1]->ptr));
+
+        else if (strcmp(c->argv[0]->ptr, "ZADD") == 0)
+            hashval = cwSorenHash(c->argv[3]->ptr, strlen(c->argv[3]->ptr));
+
+        // printf("PROPOSE: sdslen: %ld, hdrsize: %d\n", sdslen(c->querybuf), 
+        //     sdsHdrSize(sdsReqType(sdslen(c->querybuf))));
+        
+        // printf("Manual sorenReplayFuncWrapper call...\n ");
+        // sorenReplayFuncWrapper(c->querybuf, 
+        //     sdslen(c->querybuf) + sdsHdrSize(sdsReqType(sdslen(c->querybuf))), 0, NULL);
+        // printf("Manual sorenReplayFuncWrapper call ended.\n ");
+
+        cwPropose(
+            (uint8_t*)c->querybuf,
+            sdslen(c->querybuf),
+            NULL, 0, hashval
+        );
+
+        cwMarkTsAfter(timestamp_idx);
+    }
+
     /* Exec the command */
     if (c->flags & CLIENT_MULTI &&
         c->cmd->proc != execCommand &&
         c->cmd->proc != discardCommand &&
         c->cmd->proc != multiCommand &&
         c->cmd->proc != watchCommand &&
         c->cmd->proc != quitCommand &&
@@ -4012,14 +4066,17 @@
  * returned and an error is logged. If the flag SHUTDOWN_FORCE is set, these
  * errors are logged but ignored and C_OK is returned.
  *
  * On success, this function returns C_OK and then it's OK to call exit(0). */
 int prepareForShutdown(int flags) {
     if (isShutdownInitiated()) return C_ERR;
 
+    cwDumpTs();
+    cwCleanSoren();
+
     /* When SHUTDOWN is called while the server is loading a dataset in
      * memory we need to make sure no attempt is performed to save
      * the dataset on shutdown (otherwise it could overwrite the current DB
      * with half-read data).
      *
      * Also when in Sentinel mode clear the SAVE flag and force NOSAVE. */
     if (server.loading || server.sentinel_mode)
@@ -6776,14 +6833,21 @@
 #endif
 
 int main(int argc, char **argv) {
     struct timeval tv;
     int j;
     char config_from_stdin = 0;
 
+    // Redis-Soren
+    // Author: sjoon@kaist.ac.kr
+    const int MAX_TIMESTAMP_RECORDS = 10000000;
+    
+    cwInitSoren(sorenReplayFuncWrapper);
+    cwInitTs(MAX_TIMESTAMP_RECORDS);
+
 #ifdef REDIS_TEST
     if (argc >= 3 && !strcasecmp(argv[1], "test")) {
         int flags = 0;
         for (j = 3; j < argc; j++) {
             char *arg = argv[j];
             if (!strcasecmp(arg, "--accurate")) flags |= REDIS_TEST_ACCURATE;
             else if (!strcasecmp(arg, "--large-memory")) flags |= REDIS_TEST_LARGE_MEMORY;
@@ -7074,7 +7138,59 @@
 
     aeMain(server.el);
     aeDeleteEventLoop(server.el);
     return 0;
 }
 
 /* The End */
+
+// Redis-Soren
+// Author: sjoon@kaist.ac.kr
+int sorenReplayFuncWrapper(uint8_t* arg_memaddr, size_t arg_memsz, int argc, void* argv) {
+
+    // printf("################ ----\nReplayer wrapper called.\n");
+
+    int tokn, j;
+    client* fakeclient = createClient(NULL);
+
+    fakeclient->flags = CLIENT_SCRIPT | CLIENT_DENY_BLOCKING;
+    
+    sdsfree(fakeclient->querybuf);
+    fakeclient->querybuf = sdsnewlen(arg_memaddr, arg_memsz);
+    // c->querybuf[arg_memsz - 1] = '\0';
+
+    // printf("## Dummy client: querybuf %s, len %ld\n", c->querybuf, sdslen(c->querybuf));
+
+    processMultibulkBuffer(fakeclient);
+
+    // printf("After parse: argc %ld\n", fakeclient->argc);
+
+    fakeclient->cmd = fakeclient->lastcmd = fakeclient->realcmd = lookupCommand(fakeclient->argv, fakeclient->argc);
+    sds err;
+
+    // printf("After lookupCommand\n");
+
+    if (!commandCheckExistence(fakeclient, &err)) {
+        rejectCommandSds(fakeclient, err);
+        return C_OK;
+    }
+    if (!commandCheckArity(fakeclient, &err)) {
+        rejectCommandSds(fakeclient, err);
+        return C_OK;
+    }
+
+    // printf("Before call()\n");
+    pthread_mutex_lock(&g_call_lock);
+
+    server.in_nested_call++;
+    fakeclient->cmd->proc(fakeclient);
+    server.in_nested_call--;
+
+    pthread_mutex_unlock(&g_call_lock);
+
+    // printf("After call()\n");
+
+    freeClient(fakeclient);
+
+    return 0;
+}
+
--- src/server-orig.h	2023-06-26 17:29:28.056028109 +0900
+++ src/server.h	2023-06-26 17:29:28.074028109 +0900
@@ -2538,14 +2538,20 @@
 void protectClient(client *c);
 void unprotectClient(client *c);
 void initThreadedIO(void);
 client *lookupClientByID(uint64_t id);
 int authRequired(client *c);
 void putClientInPendingWriteQueue(client *c);
 
+// Redis-Soren
+// Author: sjoon@kaist.ac.kr
+// Make it visible
+int processInlineBuffer(client *c);
+int processMultibulkBuffer(client *c);
+
 #ifdef __GNUC__
 void addReplyErrorFormatEx(client *c, int flags, const char *fmt, ...)
     __attribute__((format(printf, 3, 4)));
 void addReplyErrorFormat(client *c, const char *fmt, ...)
     __attribute__((format(printf, 2, 3)));
 void addReplyStatusFormat(client *c, const char *fmt, ...)
     __attribute__((format(printf, 2, 3)));
--- src/sds-orig.c	2023-06-26 17:29:28.059028109 +0900
+++ src/sds.c	2023-06-26 17:29:28.075028109 +0900
@@ -37,15 +37,18 @@
 #include <assert.h>
 #include <limits.h>
 #include "sds.h"
 #include "sdsalloc.h"
 
 const char *SDS_NOINIT = "SDS_NOINIT";
 
-static inline int sdsHdrSize(char type) {
+// Redis-Soren
+// Author: sjoon@kaist.ac.kr
+// Make it visible
+inline int sdsHdrSize(char type) {
     switch(type&SDS_TYPE_MASK) {
         case SDS_TYPE_5:
             return sizeof(struct sdshdr5);
         case SDS_TYPE_8:
             return sizeof(struct sdshdr8);
         case SDS_TYPE_16:
             return sizeof(struct sdshdr16);
@@ -53,15 +56,18 @@
             return sizeof(struct sdshdr32);
         case SDS_TYPE_64:
             return sizeof(struct sdshdr64);
     }
     return 0;
 }
 
-static inline char sdsReqType(size_t string_size) {
+// Redis-Soren
+// Author: sjoon@kaist.ac.kr
+// Make it visible
+inline char sdsReqType(size_t string_size) {
     if (string_size < 1<<5)
         return SDS_TYPE_5;
     if (string_size < 1<<8)
         return SDS_TYPE_8;
     if (string_size < 1<<16)
         return SDS_TYPE_16;
 #if (LONG_MAX == LLONG_MAX)
--- src/sds-orig.h	2023-06-26 17:29:28.062028109 +0900
+++ src/sds.h	2023-06-26 17:29:28.075028109 +0900
@@ -276,12 +276,18 @@
  * Sometimes the program SDS is linked to, may use a different set of
  * allocators, but may want to allocate or free things that SDS will
  * respectively free or allocate. */
 void *sds_malloc(size_t size);
 void *sds_realloc(void *ptr, size_t size);
 void sds_free(void *ptr);
 
+// Redis-Soren
+// Author: sjoon@kaist.ac.kr
+// Make it visible
+int sdsHdrSize(char type);
+char sdsReqType(size_t string_size);
+
 #ifdef REDIS_TEST
 int sdsTest(int argc, char *argv[], int flags);
 #endif
 
 #endif
